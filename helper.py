# helper.py

"""
Documentation:

Dependencies:
Requires argparse, search.semantic_search, db.get_claims_by_status, and synthesize.synthesize_answer.

Key Functions:
The script implements a sequential, three-step RAG process driven by command-line arguments.

    Argument Parsing and Configuration
    The script accepts a required query (the user's question). It also accepts two optional arguments to customize the context:
    --status: Filters claims by their belief status (promoted, demoted, unreviewed, all). It defaults to promoted, ensuring only high-confidence facts are used by default.
    --top_k: Specifies the number of top relevant claims to retrieve from the vector database.

    RAG Pipeline Execution
    Retrieval: It calls semantic_search to search the Claim Vector Store (Qdrant knowledge_base) for the top K relevant claims. Crucially, it retrieves the claims' IDs.
    Filtering/Augmentation: It calls get_claims_by_status to retrieve all claims matching the --status filter from the SQLite database. It then cross-references the claim_ids from the search results with the status-filtered claims. This results in a final list of filtered_claims that are both high-relevance and high-status.
    Generation: It calls synthesize_answer, passing the user's original query and the final, curated filtered_claims list to the LLM for answer generation.

    Output
    The script prints the Synthesized Answer generated by the LLM. It then prints the list of Claims Used, including the text and source reference for each, ensuring the entire RAG process is fully transparent and traceable.
"""

import argparse
from search import semantic_search
from db import get_claims_by_status
from synthesize import synthesize_answer


def main():
    parser = argparse.ArgumentParser(description="Main CLI for semantic search and synthesis.")
    parser.add_argument("query", help="Your search question.")
    parser.add_argument("--status", choices=["promoted", "demoted", "unreviewed", "all"], default="promoted",
                        help="Filter claims by status.")
    parser.add_argument("--top_k", type=int, default=5, help="Number of top search results to use.")
    args = parser.parse_args()

    # Step 1: Semantic search
    search_results = semantic_search(args.query, top_k=args.top_k)
    print("Search Results:", search_results)
    # Each result should have claim_id

    # Step 2: Filter claims by status
    filtered_claims = []
    claims = get_claims_by_status(args.status)
    for result in search_results:
        claim_id = int(result.get("claim_id"))
        for claim in claims:
            if int(claim.get("claim_id")) == claim_id:
                filtered_claims.append(claim)
    
    if not filtered_claims:
        print("No claims found for the selected filters.")
        return
    
    # Step 3: Snythsize answer
    answer = synthesize_answer(args.query, filtered_claims)
    print("\n--- Synthesized Answer ---\n")
    print(answer)
    print("\n--- Claims Used ---")
    for claim in filtered_claims:
        print(f"- {claim['claim_text']} (Source: {claim['source_ref']})")
    
if __name__ == "__main__":
    main()